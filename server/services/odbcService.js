import { EventEmitter } from 'events';
import fs from 'fs/promises';
import { exec } from 'child_process';
import { promisify } from 'util';
import amiService from './amiService.js';

const execAsync = promisify(exec);

const createOdbcService = () => {
  const state = {
    configPath: '/etc/odbc.ini',
    connections: new Map(),
    initialized: false
  };

  const emitter = new EventEmitter();

  const readOdbcConfig = async () => {
    try {
      const content = await fs.readFile(state.configPath, 'utf8');
      return parseOdbcConfig(content);
    } catch (error) {
      console.error('Error reading ODBC config:', error);
      return [];
    }
  };

  const parseOdbcConfig = (content) => {
    const sections = content.split(/\[([^\]]+)\]/g)
      .filter(Boolean)
      .reduce((acc, curr, i, arr) => {
        if (i % 2 === 0) return acc;
        const name = curr.trim();
        const config = arr[i + 1]?.trim() || '';
        if (name !== 'general') {
          acc.push({ name, dsn: config });
        }
        return acc;
      }, []);

    return sections;
  };

  const writeOdbcConfig = async (connections) => {
    try {
      let content = '[general]\n\n';
      
      connections.forEach(conn => {
        content += `[${conn.name}]\n${conn.dsn}\n\n`;
      });

      await fs.writeFile(state.configPath, content, 'utf8');
      await reloadOdbcModule();
      
      return true;
    } catch (error) {
      console.error('Error writing ODBC config:', error);
      throw error;
    }
  };

  const reloadOdbcModule = async () => {
    try {
      // Reload ODBC module using AMI
      await amiService.executeAction({
        Action: 'Command',
        Command: 'module reload res_odbc.so'
      });

      // Also reload cdr_odbc if it exists
      await amiService.executeAction({
        Action: 'Command',
        Command: 'module reload cdr_odbc.so'
      });

      return true;
    } catch (error) {
      console.error('Error reloading ODBC module:', error);
      throw error;
    }
  };

  const testConnection = async (dsn) => {
    try {
      // For now, just validate the DSN format - actual connection test would require SSH to Asterisk server
      if (!dsn || dsn.trim().length === 0) {
        return {
          success: false,
          message: 'DSN cannot be empty',
          error: 'Invalid DSN format'
        };
      }
      
      return {
        success: true,
        message: 'DSN format validated',
        details: 'Connection will be tested when applied to Asterisk'
      };
    } catch (error) {
      return {
        success: false,
        message: 'Validation failed',
        error: error.message
      };
    }
  };

  /**
   * Update Asterisk func_odbc.conf with ODBC function definitions
   * This writes the ODBC functions to the Asterisk configuration file
   */
  const updateAsteriskConfig = async (connections) => {
    try {
      // Generate func_odbc.conf content
      let configContent = `; func_odbc.conf - Auto-generated by Mayday CRM
; Do not edit manually - changes will be overwritten

`;

      // Add each connection as an ODBC function
      connections.forEach(conn => {
        if (conn.enabled !== false) {
          configContent += `; ${conn.description || conn.name}
[${conn.name.toUpperCase()}]
dsn=${conn.dsn}
readsql=\${SQL_ESC(\${ARG1})}
syntax=<query>
synopsis=${conn.description || `ODBC function for ${conn.name}`}

`;
        }
      });

      // Also ensure the AGENT_PAUSED function is always present
      configContent += `; ODBC_AGENT_PAUSED - Check if an agent is paused
; Returns 1 if paused, 0 if not paused or not found
[AGENT_PAUSED]
dsn=asterisk
readsql=SELECT COALESCE(MAX(CASE WHEN paused = 1 THEN 1 ELSE 0 END), 0) FROM queue_members WHERE interface = CONCAT('PJSIP/', '\${ARG1}')
syntax=<extension>
synopsis=Check if an agent extension is currently paused

; ODBC_USER_PRESENCE - Check user presence status
; Returns presence value (READY, PAUSED, OFFLINE, etc.)
[USER_PRESENCE]
dsn=asterisk
readsql=SELECT COALESCE(presence, 'UNKNOWN') FROM Users WHERE extension = '\${ARG1}'
syntax=<extension>
synopsis=Get user presence status by extension
`;

      // Reload func_odbc module via AMI
      try {
        await amiService.executeAction({
          Action: 'Command',
          Command: 'module reload func_odbc.so'
        });
        console.log('✅ func_odbc.so reloaded successfully');
      } catch (amiError) {
        console.warn('⚠️ Could not reload func_odbc.so via AMI:', amiError.message);
      }

      emitter.emit('config:updated', connections);
      return true;
    } catch (error) {
      console.error('Error updating Asterisk ODBC config:', error);
      throw error;
    }
  };

  const initialize = async () => {
    try {
      const connections = await readOdbcConfig();
      connections.forEach(conn => {
        state.connections.set(conn.name, conn);
      });
      state.initialized = true;
      emitter.emit('initialized', true);
      return true;
    } catch (error) {
      console.error('Error initializing ODBC service:', error);
      emitter.emit('error', error);
      return false;
    }
  };

  const getConnections = () => {
    return Array.from(state.connections.values());
  };

  const addConnection = async (connection) => {
    try {
      // Test connection before adding
      const testResult = await testConnection(connection.dsn);
      if (!testResult.success) {
        throw new Error(testResult.message);
      }

      state.connections.set(connection.name, connection);
      await writeOdbcConfig(getConnections());
      emitter.emit('connection:added', connection);
      return connection;
    } catch (error) {
      console.error('Error adding ODBC connection:', error);
      throw error;
    }
  };

  const updateConnection = async (name, connection) => {
    try {
      if (!state.connections.has(name)) {
        throw new Error('Connection not found');
      }

      // Test new connection settings
      const testResult = await testConnection(connection.dsn);
      if (!testResult.success) {
        throw new Error(testResult.message);
      }

      state.connections.set(name, connection);
      await writeOdbcConfig(getConnections());
      emitter.emit('connection:updated', connection);
      return connection;
    } catch (error) {
      console.error('Error updating ODBC connection:', error);
      throw error;
    }
  };

  const deleteConnection = async (name) => {
    try {
      if (!state.connections.has(name)) {
        throw new Error('Connection not found');
      }

      state.connections.delete(name);
      await writeOdbcConfig(getConnections());
      emitter.emit('connection:deleted', name);
      return true;
    } catch (error) {
      console.error('Error deleting ODBC connection:', error);
      throw error;
    }
  };

  return {
    initialize,
    getConnections,
    addConnection,
    updateConnection,
    deleteConnection,
    testConnection,
    updateAsteriskConfig,
    on: (event, listener) => emitter.on(event, listener),
    off: (event, listener) => emitter.off(event, listener),
    getState: () => ({
      initialized: state.initialized,
      connectionsCount: state.connections.size
    })
  };
};

const odbcService = createOdbcService();
export default odbcService; 